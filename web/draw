<!DOCTYPE html>
<html>
<head>
<!-- Load the Paper.js library -->
<script src="js/three.js"></script>

<script type="text/javascript" src="js/paper-full.js"></script>
<script type="text/javascript" src="js/zingtouch-min.js"></script>
<script src="js/controls/OrbitControls.js"></script>
<script src="js/controls/DragControls.js"></script>
<script src="js/controls/TrackballControls.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/annyang/2.6.0/annyang.min.js"></script>

<!-- Define inlined JavaScript -->
<style>
canvas {
	position: absolute;
	height: 100vh;
	top: 0;
	left: 0;
}
</style>
</head>
<body>
	<canvas id="info" style="width 100%;height:100vh;"></canvas>
	<canvas id="paperCanvas" style="position: relative; width:100%; height:97vh;" resize></canvas>
</body>
<footer>
	<!--	<script src="js/george.js"></script> --></!>

	<script type="text/javascript">

canvas = document.getElementById("paperCanvas");
canvas.style.height = window.innerheight;
paper.install(window);

//toggle pen
//space
//TODO:double tap

//change color
//TODO:tap and hold
//TODO:XY axis color picker

//change opacity & width
//TODO:double tap and hold
//TODO:XY opacity and width picker

//toggle typing mode with (alt)

//clear project (del)
//change colors rgb with keys (r,g,b)
//change pen size with keys (1,2,3)
//change pen opacity with keys (7,8,9)

//add text to annotation

//annotations per page

//shared annotations

//interactive annotations
var timewarp = 1;
var pen = false;

var symbols = [];
var activeSymbol = -1;

window.onload = function() {
	var penColor = 'black';
	var penWidth = 1;
	var penOpacity = 0.5;
	paper.setup('paperCanvas');
	var penTool = new Tool();
	var path;
	var typing = false;
	var buffer = 'tjena\nalt toggles typing\nspace toggles pen\n1,2,3 sizes pen\n7,8,9 changes opacity\nr,g,b changes color\nclick to select\ntab defines symbol\ndelete clears everything';
	var text = new PointText(new Point(20,20));
	text.fillColor = 'black';
	text.content = buffer;

	setPenColor = function(c) {
		penColor=c;
	}
	setPenWidth = function(w) {
		penWidth=w;
	}
	setPenOpacity = function(o) {
		penOpacity = o;
	}

	drawSymbols = function() {
		for(i=0; i<symbols.length; i++) {
			var instance = symbols[i].place(view.center);
		}
	}

	penTool.minDistance = 10;

	penTool.onMouseDown = function(event) {
		if(pen) {
			path = new Path();
			path.strokeColor = penColor;
			path.fillColor = penColor;
			//path.fillColor = {hue:Math.random()*360,opacity:0.5,saturation:1,brightness:1};
			//path.strokeWidth = penWidth;
			path.strokeColor.alpha = penOpacity;
			path.fillColor.alpha = penOpacity;
			path.onClick = function(event) {
				this.fullySelected = !this.fullySelected;
			}
			path.add(event.point);
		}
	}
	penTool.onMouseDrag = function(event) {
		if(pen) {
			var step = event.delta.multiply(penWidth/4);
			//console.log(event.delta);
			step.angle += 90;
			//console.log(step.angle);
			var cap = event.point.add(step);
			console.log(cap);
			var bottom = event.point.subtract(step);
			//console.log(event.middlePoint+-step);
			path.add(cap);
			//console.log(cap);
			path.insert(0, bottom);
			path.smooth({type: 'catmull-rom', factor:0});

			//path.add(event.point);
			//console.log(path);
			//path.strokeWidth = event.delta.length/2;
			}
		}
	penTool.onMouseUp = function(event) {
			if(pen) {
				path.add(event.point);
				path.closed = true;
				path.smooth({type: 'catmull-rom', factor: 0});
				console.log(path);
				//path.fullySelected = true;
			}
		}
	penTool.onKeyDown = function(event) {
		if(typing) {
			if(event.key == 'alt') {
				console.log('alt');
				typing = !typing;
			} else if(event.key == 'backspace') {
				text.content = text.content.substring(0,text.content.length - 1);
			}
			else {
				text.content += event.character;
				console.log(text.content);
			}
		}

		else {
			if(event.key == 'alt') {
				console.log('alt');
				typing = !typing;
			}
			else if(event.key == 'space') {
				pen = !pen;
			}
			else if(event.key == 'escape') {
				project.deselectAll();
			}
			else if(event.key == 'tab') {
				symbols.push(new SymbolDefinition(new Group(project.selectedItems)));
				drawSymbols();
			}
			else if(event.key == 'r'){
				setPenColor('#ff0000');
			}
			else if(event.key == 'g') {
				setPenColor('#00ff00');
			}
			else if(event.key == 'b') {
				setPenColor('#0000ff');
			}
			else if(event.key == '1') {
				setPenWidth(1);
			}
			else if(event.key == '2') {
				setPenWidth(3);
			}
			else if(event.key == '3') {
				setPenWidth(7);
			}
			else if(event.key == '7') {
				setPenOpacity(0.1);
			}
			else if(event.key == '8') {
				setPenOpacity(0.4);
			}
			else if(event.key == '9') {
				setPenOpacity(1);
			}
			else if(event.key == 'delete'){
				paper.project.clear();
			}
		}
	}

	function echo(tag) {
		console.log(tag);
	}

	function setTimewarp(t) {
		//check if number
		timewarp = t;
	}

	if (annyang) {
		// Add our commands to annyang
		annyang.addCommands({
			'hello': function() { alert('Hello world!');},
			'(toggle) pen': function() {pen =! pen;},
			'english':function() {annyang.setLanguage('en-US');},
			'swedish':function() {annyang.setLanguage('sv-SE');},
			'tjena':function() {alert('tjena');},
			'clear all':function() {paper.project.clear();},
			'echo *tag': echo,
			'color :c': setPenColor,
			'opacity :o': setPenOpacity,
			'stroke :w': setPenWidth,
			'(set) time (warp) :t': setTimewarp,
			'background :c': bgColor
		});
		annyang.debug([newState=true]);


		annyang.addCallback('result', function(phrases) {
			  console.log("I think the user said: ", phrases[0]);
			    console.log("But then again, it could be any of the following: ", phrases);
		});

		annyang.addCallback('resultNoMatch', function(phrases) {
			  console.log("I think the user said: ", phrases[0]);
			    console.log("But then again, it could be any of the following: ", phrases);
		});

		annyang.addCallback('soundstart', function() {
			  console.log('sound detected');
		});




		annyang.addCallback('resultMatch', function(userSaid, commandText, phrases) {
			  console.log(userSaid);
			    console.log(commandText);
			      console.log(phrases);
		});

		// pass local context to a global function called notConnected
		//annyang.addCallback('errorNetwork', notConnected, this);
		annyang.start({continuous:true});

	}



var g = {
		"object":["{",["string:value"],"}"],
			"array":["[",["value"],"]"],
				"value":["string","number", "object", "array", "true", "false", "null"],
					"string":["\"", ["unicode"], ["\\", ["\"", "\\", "\/", "\b", "\f", "\n", "\r", "\t", "\u0000"]], "\""],
						"number":[["-"],[0],["."],["digit"], ["e", "E", ["+","-"], "digit"]],
							"digit":[0,1,2,3,4,5,6,7,8,9]
}
var camera, scene, renderer, controls, geometry, root;
var info = document.getElementById("paperCanvas");
info.style.zIndex = 1;
var objects = [];

var mouseX = 0, mouseY = 0;

var windowHalfX = window.innerWidth / 2;
var windowHalfY = window.innerHeight / 2;

init();
animate();

function drawObject(obj) {
	var x=0, y=0, z=0, i=0;
	var object = new THREE.Shape();
	for (var variable in obj) {
		if (obj.hasOwnProperty(variable)) {
			object.bezierCurveTo(x+5000,y+5000,z+5000,x*i*100,y*i*100,z);
			console.log(variable, obj[variable]);
			info.innerHTML += " " + variable;
			i++;
		}
	}
	var objGeo = new THREE.ShapeGeometry(object);
	var objMat = new THREE.MeshBasicMaterial({color:0x00ff00});
	var objMesh = new THREE.Mesh(objGeo, objMat);
	scene.add(objMesh);
}

//scene = new THREE.Scene();

function bgColor(c) {
	scene.background = new THREE.Color(c);
}

function init() {
	camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 150000 );
	camera.position.set(10000,10000,500);
	controls = new THREE.OrbitControls(camera);
	controls.update();
	scene = new THREE.Scene();
	scene.background = new THREE.Color( 0x333333 );
	drawObject(g);
	var loader = new THREE.FontLoader();
	loader.load( 'fonts/helvetiker_regular.typeface.json', function ( font ) {
		var xMid, text;
		var color = 0x006699;
		var matDark = new THREE.LineBasicMaterial( {
			color: color,
			side: THREE.DoubleSide
			} );
		var matLite = new THREE.MeshBasicMaterial( {
			color: color,
			transparent: true,
			opacity: 0.4,
			side: THREE.DoubleSide
			} );
		var message = "   Three.js\nSimple text.";
		var shapes = font.generateShapes( message, 100 );
		var geometry = new THREE.ShapeBufferGeometry( shapes );
		geometry.computeBoundingBox();
		xMid = - 0.5 * ( geometry.boundingBox.max.x - geometry.boundingBox.min.x );
		geometry.translate( xMid, 0, 0 );
		// make shape ( N.B. edge view not visible )
		text = new THREE.Mesh( geometry, matLite );
		text.position.z = - 150;
		scene.add( text );
		// make line shape ( N.B. edge view remains visible )
		var holeShapes = [];
		for ( var i = 0; i < shapes.length; i ++ ) {
			var shape = shapes[ i ];
			if ( shape.holes && shape.holes.length > 0 ) {
				for ( var j = 0; j < shape.holes.length; j ++ ) {
					var hole = shape.holes[ j ];
					holeShapes.push( hole );
				}
			}
		}
		shapes.push.apply( shapes, holeShapes );
	 	var lineText = new THREE.Object3D();
	 	for ( var i = 0; i < shapes.length; i ++ ) {
			var shape = shapes[ i ];
			var points = shape.getPoints();
			var geometry = new THREE.BufferGeometry().setFromPoints( points );
			geometry.translate( xMid, 0, 0 );
			var lineMesh = new THREE.Line( geometry, matDark );
			lineText.add( lineMesh );
		}
		scene.add( lineText );
		} ); //end load function
	var geometry = new THREE.BoxBufferGeometry( 100, 100, 100 );
	// var material = new THREE.MeshNormalMaterial();
	var material = new THREE.MeshNormalMaterial({"wireframe":true});
	// material.flatshading = true;
	root = new THREE.Mesh( geometry, material );
	root.position.x = 1000;
	scene.add( root );
	var amount = 200, object, parent = root;
	for ( var i = 0; i < amount; i ++ ) {
		object = new THREE.Mesh( geometry, material );
		object.position.x = 100;
		parent.add( object );
		objects.push(object);
		parent = object;
	}
	parent = root;
	for ( var i = 0; i < amount; i ++ ) {
		object = new THREE.Mesh( geometry, material );
		object.position.x = - 100;
		parent.add( object );
		objects.push(object);
		parent = object;
	}
	parent = root;
	for ( var i = 0; i < amount; i ++ ) {
	object = new THREE.Mesh( geometry, material );
	object.position.y = - 100;
	parent.add( object );
	objects.push(object);
	parent = object;
 	}
 	parent = root;
 	for ( var i = 0; i < amount; i ++ ) {
 		object = new THREE.Mesh( geometry, material );
 		object.position.y = 100;
 		parent.add( object );
 		objects.push(object);
 		parent = object;
 	}
 	parent = root;
 	for ( var i = 0; i < amount; i ++ ) {
 		object = new THREE.Mesh( geometry, material );
		object.position.z = - 100;
 		parent.add( object );
 		objects.push(object);
 		parent = object;
 	}
 	parent = root;
 	for ( var i = 0; i < amount; i ++ ) {
 		object = new THREE.Mesh( geometry, material );
 		object.position.z = 100;
 		parent.add( object );
 		objects.push(object);
 		parent = object;
 	}
 	renderer = new THREE.WebGLRenderer( { antialias: true } );
 	renderer.setPixelRatio( window.devicePixelRatio );
 	renderer.setSize( window.innerWidth, window.innerHeight );
 	document.body.appendChild( renderer.domElement );
 	var dragControls = new THREE.DragControls( objects, camera, renderer.domElement );
 	dragControls.addEventListener( 'dragstart', function ( event ) { controls.enabled = false; } );
 	dragControls.addEventListener( 'dragend', function ( event ) { controls.enabled = true; } );
 	window.addEventListener( 'resize', onWindowResize, false );
 }
 function onWindowResize() {
 	windowHalfX = window.innerWidth / 2;
 	windowHalfY = window.innerHeight / 2;
 	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
 	renderer.setSize( window.innerWidth, window.innerHeight );
 }
 //
 function animate() {
 	requestAnimationFrame( animate );
 	render();
}

function render() {
	var time = Date.now() * 0.0001 * timewarp;
 	var rx = Math.sin( time * 0.7 ) * 0.2;
	var ry = Math.sin( time * 0.3 ) * 0.1;
 	var rz = Math.sin( time * 0.2 ) * 0.1;
	//camera.position.x += ( mouseX - camera.position.x ) * 0.05;
 	//camera.position.y += ( - mouseY - camera.position.y ) * 0.05;
 	camera.lookAt( scene.position );
 	root.traverse( function ( object ) {
 		object.rotation.x = rx;
 		object.rotation.y = ry;
 		object.rotation.z = rz;
 	} );
 	controls.update();
 	renderer.render( scene, camera );
}
}
	</script>

</footer>
</html>
